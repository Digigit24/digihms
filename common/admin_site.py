from django.contrib import admin
from django.contrib.auth import REDIRECT_FIELD_NAME
from django.contrib.auth.views import redirect_to_login
from django.http import HttpResponseRedirect
from django.urls import reverse
from django.utils.translation import gettext as _
from django.views.decorators.cache import never_cache
from django.views.decorators.csrf import csrf_protect
from django.utils.decorators import method_decorator
from django.contrib.admin import AdminSite
from django.shortcuts import render
import logging

logger = logging.getLogger(__name__)


class TenantAdminSite(AdminSite):
    """
    Custom admin site that handles tenant-based authentication
    """

    site_title = _('DigiHMS Administration')
    site_header = _('DigiHMS Admin')
    index_title = _('Welcome to DigiHMS Administration')

    def __init__(self, name='admin'):
        super().__init__(name)
        self.login_template = 'admin/login.html'

    def has_permission(self, request):
        """
        Check if the current user has permission to view the admin site.
        """
        # Check if user is authenticated via session
        if hasattr(request, 'session'):
            jwt_token = request.session.get('jwt_token')
            user_data = request.session.get('user_data')

            if jwt_token and user_data:
                # Create a temporary user object for admin
                from .auth_backends import TenantUser
                request.user = TenantUser(user_data)

                # Set tenant information on request
                request.tenant_id = user_data.get('tenant_id')
                request.tenant_slug = user_data.get('tenant_slug')
                request.permissions = user_data.get('permissions', {})
                request.enabled_modules = user_data.get('enabled_modules', [])

                return True

        # Check if user is authenticated via JWT middleware (API requests)
        if hasattr(request, 'user_id') and hasattr(request, 'tenant_id'):
            # Create a temporary user object for admin
            from .auth_backends import TenantUser
            user_data = {
                'user_id': request.user_id,
                'email': getattr(request, 'email', ''),
                'tenant_id': request.tenant_id,
                'tenant_slug': getattr(request, 'tenant_slug', ''),
                'is_super_admin': getattr(request, 'is_super_admin', False),
                'permissions': getattr(request, 'permissions', {}),
                'enabled_modules': getattr(request, 'enabled_modules', [])
            }
            request.user = TenantUser(user_data)
            return True

        return False

    @method_decorator(never_cache)
    def login(self, request, extra_context=None):
        """
        Display the login form for the given HttpRequest.
        """
        if request.method == 'GET' and self.has_permission(request):
            # Already logged in, redirect to index
            index_path = reverse('admin:index', current_app=self.name)
            return HttpResponseRedirect(index_path)

        # Use our custom login view
        from .views import SuperAdminLoginView
        login_view = SuperAdminLoginView.as_view(
            template_name=self.login_template or 'admin/login.html',
            extra_context=extra_context or {}
        )
        return login_view(request)

    def logout(self, request, extra_context=None):
        """
        Log out the user and display the logout page.
        """
        from .views import admin_logout_view
        return admin_logout_view(request)

    def get_app_list(self, request):
        """
        Get the list of apps and models for the admin index.
        Override to handle tenant-specific models gracefully.
        """
        from django.db import connection
        from django.contrib.admin.sites import site

        app_dict = {}

        for model, model_admin in self._registry.items():
            app_label = model._meta.app_label

            # Skip models that don't have permission
            if hasattr(request, 'user') and hasattr(request.user, 'has_module_perms'):
                if not request.user.has_module_perms(app_label):
                    continue

            # Try to check if model has table, skip if it doesn't (tenant-specific models)
            try:
                # Check if user has permission to view this model
                has_view_perm = model_admin.has_view_permission(request)
                has_add_perm = model_admin.has_add_permission(request)
                has_change_perm = model_admin.has_change_permission(request)
                has_delete_perm = model_admin.has_delete_permission(request)

                if not (has_view_perm or has_add_perm or has_change_perm or has_delete_perm):
                    continue

                # Build model dict
                model_dict = {
                    'name': str(model._meta.verbose_name_plural),
                    'object_name': model._meta.object_name,
                    'perms': {
                        'add': has_add_perm,
                        'change': has_change_perm,
                        'delete': has_delete_perm,
                        'view': has_view_perm,
                    },
                }

                if has_view_perm:
                    model_dict['view_only'] = not (has_add_perm or has_change_perm or has_delete_perm)

                if has_change_perm or has_view_perm:
                    model_dict['admin_url'] = reverse(
                        f'admin:{app_label}_{model._meta.model_name}_changelist',
                        current_app=self.name
                    )
                if has_add_perm:
                    model_dict['add_url'] = reverse(
                        f'admin:{app_label}_{model._meta.model_name}_add',
                        current_app=self.name
                    )

                # Add to app dict
                if app_label in app_dict:
                    app_dict[app_label]['models'].append(model_dict)
                else:
                    app_dict[app_label] = {
                        'name': model._meta.app_config.verbose_name,
                        'app_label': app_label,
                        'app_url': reverse(
                            f'admin:app_list',
                            kwargs={'app_label': app_label},
                            current_app=self.name,
                        ),
                        'has_module_perms': True,
                        'models': [model_dict],
                    }
            except Exception as e:
                # Skip models that cause errors (e.g., table doesn't exist in current database)
                logger.debug(f"Skipping model {model._meta.label} due to error: {e}")
                continue

        # Sort the apps and models
        app_list = list(app_dict.values())
        app_list.sort(key=lambda x: x['name'].lower())
        for app in app_list:
            app['models'].sort(key=lambda x: x['name'])

        return app_list

    def index(self, request, extra_context=None):
        """
        Display the main admin index page, which lists all available apps.
        """
        if not self.has_permission(request):
            return redirect_to_login(
                request.get_full_path(),
                reverse('admin:login', current_app=self.name)
            )

        # Add tenant information to context
        extra_context = extra_context or {}
        if hasattr(request, 'user') and hasattr(request.user, 'tenant_slug'):
            extra_context.update({
                'tenant_name': request.user.tenant_slug,
                'tenant_id': request.user.tenant_id,
                'user_email': request.user.email,
                'enabled_modules': getattr(request.user, 'enabled_modules', []),
                'is_tenant_admin': True
            })

        # Get app list with error handling for tenant-specific models
        extra_context['app_list'] = self.get_app_list(request)

        return super().index(request, extra_context)

    def app_index(self, request, app_label, extra_context=None):
        """
        Display the admin index page for a single app.
        """
        if not self.has_permission(request):
            return redirect_to_login(
                request.get_full_path(),
                reverse('admin:login', current_app=self.name)
            )

        # Check if user has permission for this app
        if hasattr(request, 'user') and hasattr(request.user, 'has_module_perms'):
            if not request.user.has_module_perms(app_label):
                from django.core.exceptions import PermissionDenied
                raise PermissionDenied("You don't have permission to access this app.")

        # Add tenant information to context
        extra_context = extra_context or {}
        if hasattr(request, 'user') and hasattr(request.user, 'tenant_slug'):
            extra_context.update({
                'tenant_name': request.user.tenant_slug,
                'tenant_id': request.user.tenant_id,
                'user_email': request.user.email,
                'is_tenant_admin': True
            })

        return super().app_index(request, app_label, extra_context)


# Create the custom admin site instance
tenant_admin_site = TenantAdminSite(name='admin')


class TenantModelAdmin(admin.ModelAdmin):
    """
    Base ModelAdmin class that automatically filters by tenant_id
    """

    def get_queryset(self, request):
        """
        Filter queryset by tenant_id from request
        """
        qs = super().get_queryset(request)

        # Check if model has tenant_id field
        if hasattr(qs.model, 'tenant_id') and hasattr(request, 'tenant_id'):
            qs = qs.filter(tenant_id=request.tenant_id)

        return qs

    def save_model(self, request, obj, form, change):
        """
        Set tenant_id when saving model
        """
        if hasattr(obj, 'tenant_id') and hasattr(request, 'tenant_id'):
            if not change:  # Only set on create, not update
                obj.tenant_id = request.tenant_id

        super().save_model(request, obj, form, change)

    def has_view_permission(self, request, obj=None):
        """
        Check view permission based on tenant and user permissions
        """
        if not hasattr(request, 'user') or not request.user.is_authenticated:
            return False

        # Check if user has permission for this app
        app_label = self.model._meta.app_label
        if hasattr(request.user, 'has_module_perms'):
            return request.user.has_module_perms(app_label)

        return super().has_view_permission(request, obj)

    def has_add_permission(self, request):
        """
        Check add permission based on user permissions
        """
        if not hasattr(request, 'user') or not request.user.is_authenticated:
            return False

        app_label = self.model._meta.app_label
        model_name = self.model._meta.model_name
        perm = f"{app_label}.add_{model_name}"

        if hasattr(request.user, 'has_perm'):
            return request.user.has_perm(perm)

        return super().has_add_permission(request)

    def has_change_permission(self, request, obj=None):
        """
        Check change permission based on user permissions
        """
        if not hasattr(request, 'user') or not request.user.is_authenticated:
            return False

        app_label = self.model._meta.app_label
        model_name = self.model._meta.model_name
        perm = f"{app_label}.change_{model_name}"

        if hasattr(request.user, 'has_perm'):
            return request.user.has_perm(perm)

        return super().has_change_permission(request, obj)

    def has_delete_permission(self, request, obj=None):
        """
        Check delete permission based on user permissions
        """
        if not hasattr(request, 'user') or not request.user.is_authenticated:
            return False

        app_label = self.model._meta.app_label
        model_name = self.model._meta.model_name
        perm = f"{app_label}.delete_{model_name}"

        if hasattr(request.user, 'has_perm'):
            return request.user.has_perm(perm)

        return super().has_delete_permission(request, obj)
